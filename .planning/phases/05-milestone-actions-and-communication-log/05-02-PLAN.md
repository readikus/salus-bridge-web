---
phase: 05-milestone-actions-and-communication-log
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - providers/services/milestone-action.service.ts
  - providers/services/communication-log.service.ts
  - providers/services/sickness-case.service.ts
  - app/api/sickness-cases/[id]/milestone-actions/route.ts
  - app/api/sickness-cases/[id]/milestone-actions/[actionId]/route.ts
  - app/api/sickness-cases/[id]/communication-log/route.ts
  - app/api/sickness-cases/route.ts
  - actions/milestone-actions.ts
  - actions/communication-log.ts
  - emails/milestone-notification.tsx
autonomous: true

must_haves:
  truths:
    - "When a sickness case is created, milestone actions are automatically generated and DAY_1/DAY_3 notifications are immediately sent"
    - "When a sickness case is active, milestone actions can be generated for all due/upcoming milestones"
    - "Manager/HR can complete or skip a milestone action with notes"
    - "Manager/HR can create a communication log entry with date, type, and notes"
    - "Communication log entries cannot be edited or deleted after creation"
    - "Milestone notifications use privacy-validated email templates"
    - "Overdue actions are lazily marked when retrieving actions for a case"
  artifacts:
    - path: "providers/services/milestone-action.service.ts"
      provides: "Business logic for generating, completing, and querying milestone actions"
      exports: ["MilestoneActionService"]
    - path: "providers/services/communication-log.service.ts"
      provides: "Business logic for creating and querying communication log entries"
      exports: ["CommunicationLogService"]
    - path: "app/api/sickness-cases/[id]/milestone-actions/route.ts"
      provides: "GET list + POST generate milestone actions for a case"
      exports: ["GET", "POST"]
    - path: "app/api/sickness-cases/[id]/milestone-actions/[actionId]/route.ts"
      provides: "PATCH to complete/skip a milestone action"
      exports: ["PATCH"]
    - path: "app/api/sickness-cases/[id]/communication-log/route.ts"
      provides: "GET list + POST create communication log entries"
      exports: ["GET", "POST"]
    - path: "emails/milestone-notification.tsx"
      provides: "Email template for milestone notifications"
  key_links:
    - from: "providers/services/milestone-action.service.ts"
      to: "providers/repositories/milestone-action.repository.ts"
      via: "repository method calls"
      pattern: "MilestoneActionRepository"
    - from: "providers/services/milestone-action.service.ts"
      to: "providers/services/milestone.service.ts"
      via: "getCaseTimeline for due date computation"
      pattern: "MilestoneService.getCaseTimeline"
    - from: "providers/services/milestone-action.service.ts"
      to: "providers/services/notification.service.ts"
      via: "sendMilestoneNotification for autoComplete actions"
      pattern: "sendMilestoneNotification|NotificationService"
    - from: "providers/services/sickness-case.service.ts"
      to: "providers/services/milestone-action.service.ts"
      via: "auto-trigger on case creation"
      pattern: "MilestoneActionService.generateActionsForCase"
    - from: "app/api/sickness-cases/[id]/communication-log/route.ts"
      to: "providers/services/communication-log.service.ts"
      via: "service method calls"
      pattern: "CommunicationLogService"
---

<objective>
Create the service layer, API routes, client actions, and email template for milestone actions and communication logging. Hook milestone action generation into sickness case creation so actions are auto-generated and DAY_1/DAY_3 notifications auto-sent.

Purpose: This plan wires the data layer from Plan 01 into usable business logic and API endpoints. MilestoneActionService generates actions for a case (computing due dates from the timeline engine), allows completing/skipping actions, and sends milestone notification emails. When a case is created, actions are auto-generated and autoComplete actions (DAY_1, DAY_3) are immediately sent and marked COMPLETED. CommunicationLogService provides create + read-only access. API routes follow the established auth/permission/tenant pattern.

Output: Two services, four API route files, two client action files, one email template, and auto-trigger wiring in sickness case creation.
</objective>

<execution_context>
@/Users/ianread/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ianread/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-milestone-actions-and-communication-log/05-01-SUMMARY.md

Key existing code to reference:
@providers/services/milestone.service.ts (timeline computation -- getCaseTimeline, getEffectiveMilestones)
@providers/services/notification.service.ts (email sending pattern)
@providers/services/sickness-case.service.ts (case creation -- SicknessCaseService.create method to hook into)
@app/api/sickness-cases/route.ts (POST handler that calls SicknessCaseService.create)
@app/api/sickness-cases/[id]/timeline/route.ts (API route pattern for case sub-resources)
@emails/trigger-alert.tsx (email template pattern)
@constants/milestone-actions.ts (MILESTONE_ACTION_MAP from plan 01)
@schemas/milestone-action.ts (Zod schemas from plan 01)
@schemas/communication-log.ts (Zod schemas from plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create services and email template</name>
  <files>
    providers/services/milestone-action.service.ts
    providers/services/communication-log.service.ts
    emails/milestone-notification.tsx
  </files>
  <action>
**providers/services/milestone-action.service.ts** -- MilestoneActionService:

- `generateActionsForCase(sicknessCaseId, organisationId, client?)`:
  1. Call MilestoneService.getCaseTimeline(sicknessCaseId, organisationId, client) to get timeline entries
  2. For each timeline entry, check if a milestone_action already exists (findBySicknessCase then filter by milestoneKey)
  3. For entries without existing actions, create MilestoneAction with: organisationId, sicknessCaseId, milestoneKey, actionType (from MILESTONE_ACTION_MAP), status='PENDING', dueDate (from timeline entry)
  4. Use MilestoneActionRepository.createMany() for bulk insert of new actions
  5. **AUTO-COMPLETE step (CRITICAL):** After createMany(), iterate the newly created actions. For each where `MILESTONE_ACTION_MAP[milestoneKey].autoComplete === true` (DAY_1, DAY_3):
     a. Call `sendMilestoneNotification()` to send the notification email
     b. Call `MilestoneActionRepository.updateStatus(action.id, 'COMPLETED', null, 'Auto-sent on case creation')` to mark as COMPLETED immediately
     This ensures DAY_1 and DAY_3 notifications fire automatically when the case is reported.
  6. Return all actions for the case (existing + newly created)

- `completeAction(actionId, userId, notes?, client?)`:
  1. Load action by ID, verify it exists and status is PENDING or OVERDUE
  2. Update status to COMPLETED, set completedBy=userId, completedAt=now(), notes if provided
  3. Audit log the completion
  4. Return updated action

- `skipAction(actionId, userId, notes, client?)`:
  1. Load action by ID, verify exists and status is PENDING or OVERDUE
  2. Validate notes is non-empty (required when skipping per schema)
  3. Update status to SKIPPED, set completedBy=userId, notes
  4. Audit log the skip
  5. Return updated action

- `markOverdueActions(organisationId, client?)`:
  1. Find all PENDING actions where due_date < today for the org
  2. Bulk update status to OVERDUE
  3. Return count of updated actions (for logging)
  NOTE: This method will be called by a cron job in a future phase. For now, overdue marking is also done lazily in getActionsForCase below.

- `getActionsForCase(sicknessCaseId, organisationId?, client?)`:
  1. **Lazy overdue marking:** If organisationId is provided, call markOverdueActions(organisationId, client) before fetching. This ensures overdue statuses are current even without a cron job.
  2. Return MilestoneActionRepository.findBySicknessCaseWithDetails(sicknessCaseId, client)

- `sendMilestoneNotification(action, sicknessCase, recipients, organisationName, organisationId)`:
  1. Look up action config from MILESTONE_ACTION_MAP[action.milestoneKey]
  2. For each recipient, render MilestoneNotificationEmail and send via NotificationService.send()
  3. Fire-and-forget (catch errors, log, don't throw)

**providers/services/communication-log.service.ts** -- CommunicationLogService:

- `createEntry(params: { organisationId, sicknessCaseId, authorId, contactDate, contactType, notes }, client?)`:
  1. Validate with createCommunicationLogSchema
  2. Create via CommunicationLogRepository.create()
  3. Audit log the creation (AuditEntity.COMMUNICATION_LOG, AuditAction.CREATE)
  4. Return created entry

- `getEntriesForCase(sicknessCaseId, client?)`:
  1. Return CommunicationLogRepository.findBySicknessCase(sicknessCaseId, client)

- `getEntryCount(sicknessCaseId, client?)`:
  1. Return CommunicationLogRepository.countBySicknessCase(sicknessCaseId, client)

**emails/milestone-notification.tsx** -- MilestoneNotificationEmail:
Follow existing email template pattern (EmailLayout, Text, Button, Section).
Props: { milestoneName: string, milestoneDescription: string, organisationName: string, caseUrl: string }
Generic subject: "Absence Management - Action Required"
Body: "{milestoneName}" heading, description text, "View Case" button linking to caseUrl.
Keep content privacy-compliant: NO employee name, NO condition details, NO specific health info.
  </action>
  <verify>`npx tsc --noEmit --pretty 2>&1 | head -30` passes. Verify MilestoneActionService has generateActionsForCase, completeAction, skipAction methods. Verify generateActionsForCase contains autoComplete logic that calls sendMilestoneNotification and updateStatus for DAY_1/DAY_3. Verify CommunicationLogService has NO update or delete methods.</verify>
  <done>MilestoneActionService generates/completes/skips actions with audit logging and notification sending. autoComplete actions (DAY_1, DAY_3) are automatically sent and marked COMPLETED during generation. getActionsForCase lazily marks overdue actions. CommunicationLogService creates and reads entries (immutable). Email template renders privacy-compliant milestone notifications.</done>
</task>

<task type="auto">
  <name>Task 2: Create API routes, client actions, and hook auto-generation into case creation</name>
  <files>
    app/api/sickness-cases/[id]/milestone-actions/route.ts
    app/api/sickness-cases/[id]/milestone-actions/[actionId]/route.ts
    app/api/sickness-cases/[id]/communication-log/route.ts
    app/api/sickness-cases/route.ts
    providers/services/sickness-case.service.ts
    actions/milestone-actions.ts
    actions/communication-log.ts
  </files>
  <action>
**app/api/sickness-cases/[id]/milestone-actions/route.ts**:
- GET: Auth check (VIEW_MILESTONE_ACTIONS permission), load sickness case, TenantService.withTenant(), call MilestoneActionService.getActionsForCase(sicknessCaseId, organisationId). Return { actions: MilestoneActionWithDetails[] }. Pass organisationId so lazy overdue marking runs.
- POST: Auth check (MANAGE_MILESTONE_ACTIONS permission), load sickness case, TenantService.withTenant(), call MilestoneActionService.generateActionsForCase(). Return { actions, generated: number } with 201 status.

Follow exact pattern from app/api/sickness-cases/[id]/timeline/route.ts for auth, tenant context, and error handling.

**app/api/sickness-cases/[id]/milestone-actions/[actionId]/route.ts**:
- PATCH: Auth check (MANAGE_MILESTONE_ACTIONS), parse body for { action: 'complete' | 'skip', notes?: string }. Validate with appropriate schema (completeMilestoneActionSchema or skipMilestoneActionSchema). Load sickness case for tenant context. Call completeAction or skipAction on MilestoneActionService. Return { action: MilestoneAction }.

**app/api/sickness-cases/[id]/communication-log/route.ts**:
- GET: Auth check (VIEW_COMMUNICATION_LOG), load case, tenant context. Call CommunicationLogService.getEntriesForCase(). Return { entries: CommunicationLogEntryWithAuthor[], count: number }.
- POST: Auth check (CREATE_COMMUNICATION_LOG), parse and validate body with createCommunicationLogSchema, load case, tenant context. Call CommunicationLogService.createEntry() with authorId = sessionUser.id. Return { entry } with 201 status.

No PUT/PATCH/DELETE on communication-log route -- immutability enforced at API level.

**Auto-trigger: Hook into sickness case creation (CRITICAL for Blockers 1 & 2):**

**providers/services/sickness-case.service.ts** -- Modify the existing `SicknessCaseService.create()` method:
1. Read the existing create method to understand its flow
2. After the case is successfully created (after the INSERT and any existing post-creation logic), add a call to `MilestoneActionService.generateActionsForCase(newCase.id, organisationId, client)` wrapped in a try/catch
3. This call will automatically: (a) generate all milestone actions for the new case, (b) auto-complete and send notifications for DAY_1 and DAY_3 actions (via the autoComplete logic in generateActionsForCase)
4. If the milestone action generation fails, log the error but do NOT fail the case creation -- case creation is the primary operation
5. Import MilestoneActionService at top of file

**Alternatively**, if SicknessCaseService.create() does not have direct access to the organisationId or it is cleaner architecturally: hook the auto-generation into the POST handler in `app/api/sickness-cases/route.ts` instead, calling `MilestoneActionService.generateActionsForCase()` after `SicknessCaseService.create()` returns successfully. Use whichever approach is cleaner given the existing code structure. Either way, the auto-generation MUST happen automatically when a case is created.

**actions/milestone-actions.ts** -- Client-side fetch wrappers:
- fetchMilestoneActions(caseId: string) -- GET /api/sickness-cases/{caseId}/milestone-actions
- generateMilestoneActions(caseId: string) -- POST /api/sickness-cases/{caseId}/milestone-actions
- completeMilestoneAction(caseId: string, actionId: string, notes?: string) -- PATCH with { action: 'complete', notes }
- skipMilestoneAction(caseId: string, actionId: string, notes: string) -- PATCH with { action: 'skip', notes }

**actions/communication-log.ts** -- Client-side fetch wrappers:
- fetchCommunicationLog(caseId: string) -- GET /api/sickness-cases/{caseId}/communication-log
- createCommunicationLogEntry(caseId: string, data: { contactDate, contactType, notes }) -- POST

All actions follow established pattern: async functions prefixed with fetch*/create*/complete*/skip*, returning typed responses, throwing on non-OK status.
  </action>
  <verify>`npx tsc --noEmit --pretty 2>&1 | head -30` passes. Verify API route files exist at correct paths. Verify communication-log route has only GET and POST exports (no PUT/PATCH/DELETE). Verify that SicknessCaseService.create() or the POST /api/sickness-cases route.ts calls MilestoneActionService.generateActionsForCase after case creation.</verify>
  <done>API routes serve milestone actions (GET list, POST generate, PATCH complete/skip) and communication log (GET list, POST create). Client actions provide typed fetch wrappers. Communication log immutability enforced at API level (no update/delete endpoints). Sickness case creation automatically triggers milestone action generation and DAY_1/DAY_3 auto-notifications.</done>
</task>

</tasks>

<verification>
- All service methods handle errors with try/catch and audit logging
- API routes follow auth -> permission -> tenant context -> service call pattern
- Communication log has NO update/delete endpoints anywhere in the stack
- Email template passes privacy validation (no employee names or health details)
- Case creation auto-triggers generateActionsForCase
- autoComplete actions (DAY_1, DAY_3) are auto-sent and marked COMPLETED during generation
- getActionsForCase lazily marks overdue actions before returning
- `npx tsc --noEmit` passes
</verification>

<success_criteria>
- MilestoneActionService can generate, complete, skip, and query milestone actions
- autoComplete actions are automatically sent and completed when actions are generated
- Creating a sickness case auto-generates milestone actions (no manual "Generate Actions" click required)
- Overdue actions are lazily detected on each getActionsForCase call
- CommunicationLogService can create and query entries (no mutations)
- API routes expose all operations with proper auth and tenant scoping
- Client actions provide typed wrappers for all API operations
- Milestone notification email is privacy-compliant
</success_criteria>

<output>
After completion, create `.planning/phases/05-milestone-actions-and-communication-log/05-02-SUMMARY.md`
</output>
