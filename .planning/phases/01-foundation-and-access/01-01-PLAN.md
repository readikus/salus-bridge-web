---
phase: 01-foundation-and-access
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - next.config.ts
  - knexfile.ts
  - .env.example
  - .env.local
  - providers/database/pool.ts
  - providers/database/encryption.ts
  - providers/repositories/audit-log.repository.ts
  - providers/services/audit-log.service.ts
  - providers/services/encryption.service.ts
  - database/migrations/20260214000001_create_organisations.ts
  - database/migrations/20260214000002_create_users_and_roles.ts
  - database/migrations/20260214000003_create_employees.ts
  - database/migrations/20260214000004_create_audit_logs.ts
  - database/migrations/20260214000005_enable_rls.ts
  - types/database.ts
  - types/enums.ts
autonomous: true

must_haves:
  truths:
    - "Next.js app boots and renders a page at localhost:3000"
    - "Database connection pool connects to Supabase PostgreSQL"
    - "Knex migrations create all core tables (organisations, users, user_roles, departments, employees, audit_logs)"
    - "AES-256-GCM encryption can encrypt and decrypt a string round-trip"
    - "Audit log entries can be inserted and queried by entity"
    - "Row-level security policies isolate tenant data by organisation_id"
  artifacts:
    - path: "providers/database/pool.ts"
      provides: "PostgreSQL connection pool via pg"
      exports: ["pool"]
    - path: "providers/database/encryption.ts"
      provides: "AES-256-GCM encrypt/decrypt utilities"
      exports: ["encrypt", "decrypt"]
    - path: "providers/repositories/audit-log.repository.ts"
      provides: "Audit log data access"
      exports: ["AuditLogRepository"]
    - path: "providers/services/audit-log.service.ts"
      provides: "Audit log business logic"
      exports: ["AuditLogService"]
    - path: "types/database.ts"
      provides: "TypeScript interfaces for all database entities"
    - path: "types/enums.ts"
      provides: "Enum types for roles, audit actions, etc."
  key_links:
    - from: "providers/database/pool.ts"
      to: "Supabase PostgreSQL"
      via: "pg Pool with DATABASE_URL"
      pattern: "new Pool"
    - from: "providers/repositories/audit-log.repository.ts"
      to: "providers/database/pool.ts"
      via: "pool.query()"
      pattern: "pool\\.query"
    - from: "providers/database/encryption.ts"
      to: "ENCRYPTION_KEY env var"
      via: "crypto.createCipheriv"
      pattern: "createCipheriv.*aes-256-gcm"
---

<objective>
Scaffold the Next.js project, establish database connectivity, create the core schema via Knex migrations, and build the compliance infrastructure (encryption + audit logging).

Purpose: Everything in Phase 1 depends on tables existing and compliance tooling being available. This plan creates the foundation that auth (Plan 02) and org management (Plan 03) build upon.

Output: A bootable Next.js app with PostgreSQL connection, all core tables migrated, encryption utilities, audit logging service, and RLS policies enabled.
</objective>

<execution_context>
@/Users/ianread/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ianread/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-access/01-CONTEXT.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Next.js project with database connectivity</name>
  <files>
    package.json
    tsconfig.json
    next.config.ts
    knexfile.ts
    .env.example
    .env.local
    providers/database/pool.ts
    types/enums.ts
    types/database.ts
  </files>
  <action>
    Initialize the Next.js 16 project with App Router:
    - Run `npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir=false --import-alias="@/*"` (or configure manually if project shell exists)
    - Install core dependencies: `yarn add pg knex dotenv` and `yarn add -D @types/pg`
    - Install UI dependencies: `yarn add tailwind-merge class-variance-authority lucide-react` and shadcn/ui init
    - Install compliance/validation deps: `yarn add zod`

    Create `providers/database/pool.ts`:
    - Export a singleton pg Pool using DATABASE_URL from env
    - Include connection config: ssl rejectUnauthorized false (for Supabase), max 10 connections, idleTimeoutMillis 30000
    - Use the Supabase direct connection string format: `postgresql://postgres.[project-id]:[password]@aws-0-eu-west-2.pooler.supabase.com:6543/postgres`

    Create `knexfile.ts`:
    - Configure for PostgreSQL using the same DATABASE_URL
    - Migration directory: `database/migrations`
    - Migration table name: `knex_migrations`

    Create `.env.example` with all required env vars (no real values):
    - DATABASE_URL, ENCRYPTION_KEY, AUTH0_SECRET, AUTH0_BASE_URL, AUTH0_ISSUER_BASE_URL, AUTH0_CLIENT_ID, AUTH0_CLIENT_SECRET

    Create `types/enums.ts`:
    - UserRole enum: PLATFORM_ADMIN, ORG_ADMIN, HR, MANAGER, EMPLOYEE
    - AuditAction enum: VIEW, CREATE, UPDATE, DELETE, EXPORT, LOGIN, INVITE
    - AuditEntity enum: ORGANISATION, USER, EMPLOYEE, ROLE, AUDIT_LOG
    - OrganisationStatus enum: ACTIVE, SUSPENDED, DEACTIVATED
    - EmployeeStatus enum: ACTIVE, INVITED, DEACTIVATED
    - InvitationStatus enum: PENDING, ACCEPTED, EXPIRED

    Create `types/database.ts`:
    - TypeScript interfaces for: Organisation, User, UserRole, Department, Employee, AuditLog
    - All interfaces use camelCase property names (matching the AS aliases in SQL)
    - Organisation: id, name, slug, status, settings (JSONB), createdAt, updatedAt
    - User: id, email, auth0Id, firstName, lastName, isActive, createdAt, updatedAt
    - UserRole: id, userId, organisationId, role (UserRole enum), createdAt
    - Department: id, organisationId, name, createdAt
    - Employee: id, userId, organisationId, departmentId (nullable), managerId (nullable - self-referencing), jobTitle, status, invitationToken (nullable), invitationExpiresAt (nullable), createdAt, updatedAt
    - AuditLog: id, userId, organisationId, action, entity, entityId, metadata (JSONB), ipAddress, createdAt

    Use UUID (crypto.randomUUID or gen_random_uuid() in PG) for all primary keys.
  </action>
  <verify>
    - `yarn dev` starts without errors
    - `node -e "const {pool} = require('./providers/database/pool'); pool.query('SELECT 1').then(r => { console.log('OK'); pool.end() })"` connects successfully
    - TypeScript compiles without errors: `yarn tsc --noEmit`
  </verify>
  <done>
    Next.js app boots at localhost:3000, pg pool connects to Supabase, Knex is configured, all TypeScript types and enums defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create core database schema via Knex migrations</name>
  <files>
    database/migrations/20260214000001_create_organisations.ts
    database/migrations/20260214000002_create_users_and_roles.ts
    database/migrations/20260214000003_create_employees.ts
    database/migrations/20260214000004_create_audit_logs.ts
    database/migrations/20260214000005_enable_rls.ts
  </files>
  <action>
    Create 5 Knex migrations (run one-at-a-time per CLAUDE.md convention). Each migration has up() and down().

    Migration 1 - `create_organisations`:
    - Enable uuid-ossp extension: `CREATE EXTENSION IF NOT EXISTS "uuid-ossp"`
    - Enable pgcrypto extension: `CREATE EXTENSION IF NOT EXISTS "pgcrypto"`
    - `organisations` table: id (uuid PK default gen_random_uuid()), name (varchar 255 NOT NULL), slug (varchar 100 UNIQUE NOT NULL), status (varchar 20 NOT NULL default 'ACTIVE'), settings (jsonb default '{}'), created_at (timestamptz default now()), updated_at (timestamptz default now())
    - Index on slug (unique already covers it)
    - `departments` table: id (uuid PK), organisation_id (uuid FK organisations NOT NULL), name (varchar 255 NOT NULL), created_at (timestamptz default now())
    - Unique constraint on (organisation_id, name) for departments

    Migration 2 - `create_users_and_roles`:
    - `users` table: id (uuid PK default gen_random_uuid()), email (varchar 255 UNIQUE NOT NULL), auth0_id (varchar 255 UNIQUE), first_name (varchar 100), last_name (varchar 100), is_active (boolean default true), created_at (timestamptz default now()), updated_at (timestamptz default now())
    - Index on email, auth0_id
    - `user_roles` table: id (uuid PK default gen_random_uuid()), user_id (uuid FK users NOT NULL), organisation_id (uuid FK organisations NOT NULL), role (varchar 20 NOT NULL), created_at (timestamptz default now())
    - Unique constraint on (user_id, organisation_id, role) — allows multiple roles per user per org (per user decision: permissions are additive)
    - Index on (user_id, organisation_id)

    Migration 3 - `create_employees`:
    - `employees` table: id (uuid PK default gen_random_uuid()), user_id (uuid FK users UNIQUE), organisation_id (uuid FK organisations NOT NULL), department_id (uuid FK departments nullable), manager_id (uuid FK employees nullable — self-referencing), job_title (varchar 255), status (varchar 20 NOT NULL default 'ACTIVE'), invitation_token (varchar 255 UNIQUE nullable), invitation_expires_at (timestamptz nullable), created_at (timestamptz default now()), updated_at (timestamptz default now())
    - Index on (organisation_id), (user_id), (manager_id), (invitation_token)
    - The manager_id self-reference enables the full reporting chain (per user decision: manager scope includes direct reports AND everyone below them)

    Migration 4 - `create_audit_logs`:
    - `audit_logs` table: id (uuid PK default gen_random_uuid()), user_id (uuid FK users nullable — system actions), organisation_id (uuid FK organisations nullable — platform-level actions), action (varchar 20 NOT NULL), entity (varchar 50 NOT NULL), entity_id (uuid), metadata (jsonb default '{}'), ip_address (inet), created_at (timestamptz default now())
    - NO update or delete permissions — immutable by design (COMP-01)
    - Index on (entity, entity_id), (user_id), (organisation_id), (created_at)
    - Revoke UPDATE and DELETE on audit_logs from the application role

    Migration 5 - `enable_rls`:
    - Enable RLS on: organisations, departments, users, user_roles, employees
    - DO NOT enable RLS on audit_logs (needs cross-tenant query for platform admin)
    - Create RLS policies that restrict SELECT/INSERT/UPDATE/DELETE to rows matching organisation_id
    - Use a session variable `app.current_organisation_id` set by the application before queries:
      `ALTER TABLE organisations ENABLE ROW LEVEL SECURITY;`
      `CREATE POLICY org_isolation ON organisations USING (id = current_setting('app.current_organisation_id')::uuid);`
    - Similar policies for departments, user_roles, employees (all keyed on organisation_id)
    - Create a bypass policy for platform admins: `CREATE POLICY platform_admin_bypass ON organisations USING (current_setting('app.is_platform_admin', true)::boolean = true);`
    - users table: RLS via user_roles join (user visible if they have a role in current org)

    Run all migrations: `npx knex migrate:up` for each (one at a time per CLAUDE.md).
  </action>
  <verify>
    - Each migration runs successfully: `npx knex migrate:up` x5
    - Tables exist: `SELECT table_name FROM information_schema.tables WHERE table_schema = 'public'` includes all 6 tables
    - RLS is enabled: `SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public' AND rowsecurity = true`
    - Audit logs are immutable: attempt UPDATE on audit_logs fails
  </verify>
  <done>
    All 6 tables (organisations, departments, users, user_roles, employees, audit_logs) created with proper constraints, indexes, foreign keys. RLS enabled with organisation isolation. Audit logs are immutable.
  </done>
</task>

<task type="auto">
  <name>Task 3: Build encryption utilities and audit logging service</name>
  <files>
    providers/database/encryption.ts
    providers/repositories/audit-log.repository.ts
    providers/services/audit-log.service.ts
    providers/services/encryption.service.ts
  </files>
  <action>
    Create `providers/database/encryption.ts`:
    - Implement AES-256-GCM encryption using Node.js crypto module
    - `encrypt(plaintext: string): string` — generates random 12-byte IV, encrypts, returns `iv:authTag:ciphertext` as base64-encoded string
    - `decrypt(encrypted: string): string` — splits the stored string, decrypts, returns plaintext
    - Uses ENCRYPTION_KEY from env (must be 32 bytes / 64 hex chars)
    - Throw clear error if ENCRYPTION_KEY is missing or wrong length
    - This satisfies COMP-02: AES-256-GCM encryption at rest

    Create `providers/services/encryption.service.ts`:
    - Static class EncryptionService with methods:
      - `encryptField(value: string): string` — wraps encrypt()
      - `decryptField(value: string): string` — wraps decrypt()
      - `encryptObject(obj: Record<string, string>, fields: string[]): Record<string, string>` — encrypts specified fields in an object
      - `decryptObject(obj: Record<string, string>, fields: string[]): Record<string, string>` — decrypts specified fields

    Create `providers/repositories/audit-log.repository.ts`:
    - Static class AuditLogRepository with methods:
      - `create(entry: CreateAuditLogParams): Promise<AuditLog>` — INSERT INTO audit_logs with parameterised query, snake_case columns AS "camelCase"
      - `findByEntity(entity: string, entityId: string): Promise<AuditLog[]>` — SELECT ordered by created_at DESC
      - `findByUser(userId: string, options?: { limit?: number; offset?: number }): Promise<AuditLog[]>` — for SAR readiness (COMP-05)
      - `findByOrganisation(organisationId: string, options?: { limit?: number; offset?: number; entity?: string; action?: string }): Promise<AuditLog[]>` — filterable audit trail
    - All queries use pool.query() with parameterised SQL (per CLAUDE.md: raw SQL via pg pool)
    - SQL uses snake_case columns aliased to "camelCase" with AS

    Create `providers/services/audit-log.service.ts`:
    - Static class AuditLogService with methods:
      - `log(params: { userId?: string; organisationId?: string; action: AuditAction; entity: AuditEntity; entityId?: string; metadata?: Record<string, unknown>; ipAddress?: string }): Promise<AuditLog>` — delegates to repository
      - `getEntityHistory(entity: string, entityId: string): Promise<AuditLog[]>` — delegates to repository
      - `getUserActivity(userId: string, options?: PaginationOptions): Promise<AuditLog[]>` — for COMP-05 SAR readiness
      - `getOrganisationAuditTrail(organisationId: string, filters?: AuditFilters): Promise<AuditLog[]>`

    Define supporting interfaces in types/database.ts:
    - CreateAuditLogParams, PaginationOptions, AuditFilters
  </action>
  <verify>
    - TypeScript compiles: `yarn tsc --noEmit`
    - Encryption round-trip test: write a small script that encrypts "test data" and decrypts it, confirming equality
    - Audit log insert: write a small script that inserts an audit log entry and queries it back
  </verify>
  <done>
    AES-256-GCM encryption encrypts/decrypts round-trip. Audit log entries can be created and queried by entity, user, and organisation. EncryptionService wraps crypto operations. All services follow static class method pattern per CLAUDE.md.
  </done>
</task>

</tasks>

<verification>
1. `yarn dev` boots the app at localhost:3000
2. All 5 migrations applied successfully (6 tables exist in database)
3. RLS is enabled on tenant-scoped tables
4. Encryption round-trip works with AES-256-GCM
5. Audit log CRUD operations work (insert + query)
6. TypeScript compiles with no errors
</verification>

<success_criteria>
- Next.js project scaffolded with all dependencies installed
- PostgreSQL connection pool established to Supabase
- All core tables created: organisations, departments, users, user_roles, employees, audit_logs
- Row-level security isolates data by organisation_id
- Audit logs table is immutable (no UPDATE/DELETE)
- AES-256-GCM encryption/decryption works
- Audit logging service can create and query entries
- TypeScript types defined for all database entities
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-access/01-01-SUMMARY.md`
</output>
