---
phase: 01-foundation-and-access
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - middleware.ts
  - app/api/auth/[auth0]/route.ts
  - app/api/auth/invite/route.ts
  - app/api/auth/set-password/route.ts
  - providers/repositories/user.repository.ts
  - providers/repositories/user-role.repository.ts
  - providers/services/user.service.ts
  - providers/services/auth.service.ts
  - providers/services/tenant.service.ts
  - hooks/use-auth.ts
  - hooks/use-tenant.ts
  - types/auth.ts
  - constants/roles.ts
  - constants/permissions.ts
  - app/layout.tsx
  - app/(authenticated)/layout.tsx
  - app/invite/[token]/page.tsx
  - app/invite/[token]/set-password/page.tsx
autonomous: true

must_haves:
  truths:
    - "Admin user can log in with email/password via Auth0 and reach the authenticated dashboard"
    - "Unauthenticated user is redirected to login page"
    - "User session persists across browser refresh (AUTH-04)"
    - "Each user's roles are loaded and available in the client via useAuth hook"
    - "Tenant context (current organisation) is set on every authenticated request, enabling RLS"
    - "Employee can click magic link invitation, set a password, and access their dashboard"
    - "Magic link tokens expire after 7 days and are single-use"
    - "RBAC middleware blocks access to routes the user's role does not permit"
  artifacts:
    - path: "middleware.ts"
      provides: "Auth0 session check + route protection"
      exports: ["middleware", "config"]
    - path: "app/api/auth/[auth0]/route.ts"
      provides: "Auth0 SDK route handler"
    - path: "providers/services/user.service.ts"
      provides: "User business logic including isSuperAdmin"
      exports: ["UserService"]
    - path: "providers/services/auth.service.ts"
      provides: "Auth orchestration (login sync, invitation, role loading)"
      exports: ["AuthService"]
    - path: "providers/services/tenant.service.ts"
      provides: "Sets RLS session variable for tenant isolation"
      exports: ["TenantService"]
    - path: "hooks/use-auth.ts"
      provides: "Client-side auth state hook"
      exports: ["useAuth"]
    - path: "constants/permissions.ts"
      provides: "Role-to-permission mapping"
      exports: ["PERMISSIONS", "hasPermission"]
    - path: "app/invite/[token]/set-password/page.tsx"
      provides: "Password setup page for invited employees"
  key_links:
    - from: "middleware.ts"
      to: "@auth0/nextjs-auth0"
      via: "auth0.middleware()"
      pattern: "auth0.*middleware"
    - from: "providers/services/tenant.service.ts"
      to: "providers/database/pool.ts"
      via: "SET app.current_organisation_id"
      pattern: "current_organisation_id"
    - from: "providers/services/auth.service.ts"
      to: "providers/repositories/user.repository.ts"
      via: "findOrCreate on login"
      pattern: "findByAuth0Id|findByEmail"
    - from: "app/invite/[token]/set-password/page.tsx"
      to: "app/api/auth/set-password/route.ts"
      via: "form submission"
      pattern: "fetch.*set-password"
---

<objective>
Implement Auth0 authentication, role-based access control, tenant context for RLS, and the employee invitation/magic link flow.

Purpose: Users need to authenticate and the system needs to know WHO they are and WHAT they can do. Tenant context enables the RLS policies created in Plan 01 to function. The invitation flow is how employees first access the platform.

Output: Working login/logout flow, RBAC middleware, tenant context setting, magic link invitation with password setup, and client-side auth hooks.
</objective>

<execution_context>
@/Users/ianread/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ianread/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-access/01-CONTEXT.md
@.planning/phases/01-foundation-and-access/01-01-SUMMARY.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auth0 integration with user sync and tenant context</name>
  <files>
    middleware.ts
    app/api/auth/[auth0]/route.ts
    providers/repositories/user.repository.ts
    providers/repositories/user-role.repository.ts
    providers/services/user.service.ts
    providers/services/auth.service.ts
    providers/services/tenant.service.ts
    types/auth.ts
    constants/roles.ts
    app/layout.tsx
    app/(authenticated)/layout.tsx
  </files>
  <action>
    Install Auth0: `yarn add @auth0/nextjs-auth0@latest`

    Create `app/api/auth/[auth0]/route.ts`:
    - Use the Auth0 Next.js SDK v4 route handler pattern
    - Export GET handler that handles login, logout, callback, and profile
    - On callback (afterCallback hook): sync user to local database — find or create user by auth0_id, load their roles, store org context in session

    Create `types/auth.ts`:
    - SessionUser interface: id, email, auth0Id, firstName, lastName, roles (UserRoleWithOrg[]), currentOrganisationId
    - UserRoleWithOrg: role, organisationId, organisationName
    - Permission type and PermissionCheck type

    Create `constants/roles.ts`:
    - ROLE_HIERARCHY: Record mapping each role to its level (PLATFORM_ADMIN=5, ORG_ADMIN=4, HR=3, MANAGER=2, EMPLOYEE=1)
    - SUPER_ADMIN_EMAILS: string[] (hardcoded list per CLAUDE.md pattern — UserService.isSuperAdmin())

    Create `constants/permissions.ts`:
    - Define permissions as string constants: MANAGE_ORGANISATIONS, MANAGE_EMPLOYEES, MANAGE_ROLES, VIEW_EMPLOYEES, VIEW_OWN_DATA, IMPORT_EMPLOYEES, VIEW_AUDIT_LOG, SEND_INVITATIONS, MANAGE_SETTINGS
    - ROLE_PERMISSIONS: Record<UserRole, string[]> mapping each role to its allowed permissions
    - `hasPermission(userRoles: UserRoleWithOrg[], permission: string, organisationId?: string): boolean` — checks if any of the user's roles grant the permission, optionally scoped to org
    - Permissions are additive across roles (per user decision: multiple roles allowed, additive)

    Create `providers/repositories/user.repository.ts`:
    - Static class UserRepository:
      - `findById(id: string): Promise<User | null>`
      - `findByEmail(email: string): Promise<User | null>`
      - `findByAuth0Id(auth0Id: string): Promise<User | null>`
      - `create(params: CreateUserParams): Promise<User>`
      - `update(id: string, params: UpdateUserParams): Promise<User>`
      - `findByOrganisation(organisationId: string): Promise<User[]>` — JOIN user_roles
    - All queries: parameterised SQL, snake_case AS "camelCase"

    Create `providers/repositories/user-role.repository.ts`:
    - Static class UserRoleRepository:
      - `findByUserId(userId: string): Promise<UserRoleWithOrg[]>` — JOIN organisations for name
      - `findByUserAndOrg(userId: string, organisationId: string): Promise<UserRole[]>`
      - `create(params: CreateUserRoleParams): Promise<UserRole>`
      - `delete(userId: string, organisationId: string, role: string): Promise<void>`
      - `hasRole(userId: string, organisationId: string, role: string): Promise<boolean>`

    Create `providers/services/user.service.ts`:
    - Static class UserService:
      - `findOrCreateFromAuth0(auth0Profile: Auth0Profile): Promise<User>` — find by auth0_id first, then by email, create if neither found
      - `isSuperAdmin(email: string): boolean` — check against SUPER_ADMIN_EMAILS constant
      - `getUserWithRoles(userId: string): Promise<SessionUser>` — combines user + roles
      - `assignRole(userId: string, organisationId: string, role: UserRole): Promise<UserRole>` — delegates to UserRoleRepository, logs to audit

    Create `providers/services/auth.service.ts`:
    - Static class AuthService:
      - `handleLoginCallback(auth0Profile: Auth0Profile): Promise<SessionUser>` — orchestrates: findOrCreate user, load roles, determine currentOrganisationId (first org or platform-level if super admin)
      - `getSessionUser(auth0Id: string): Promise<SessionUser | null>`
      - `validateAccess(user: SessionUser, permission: string, organisationId?: string): boolean` — wraps hasPermission

    Create `providers/services/tenant.service.ts`:
    - Static class TenantService:
      - `setTenantContext(client: PoolClient, organisationId: string, isPlatformAdmin: boolean): Promise<void>` — executes `SET LOCAL app.current_organisation_id = $1` and `SET LOCAL app.is_platform_admin = $2` within a transaction
      - `withTenant<T>(organisationId: string, isPlatformAdmin: boolean, fn: (client: PoolClient) => Promise<T>): Promise<T>` — wraps a callback in a transaction with tenant context set. Gets client from pool, begins transaction, sets context, calls fn, commits, releases client.
    - This is the critical link making RLS work: every data query goes through withTenant()

    Create `middleware.ts`:
    - Use Auth0 SDK v4 middleware pattern
    - Protect all routes under `/(authenticated)/*`
    - Allow public routes: `/`, `/api/auth/*`, `/invite/*`
    - On authenticated requests: attach user info to headers for server components

    Create `app/layout.tsx`:
    - Root layout with Auth0 UserProvider wrapper
    - Include React Query provider (QueryClientProvider)
    - Basic HTML structure with Tailwind

    Create `app/(authenticated)/layout.tsx`:
    - Authenticated layout shell — shared sidebar + main content area
    - Navigation items filtered by role (per user decision: shared layout with filtered navigation)
    - Show org name in sidebar header, user info in sidebar footer
    - Use Server Component where possible; client wrapper only for interactive nav elements
    - Navigation structure (Claude's discretion):
      - Platform Admin: Organisations, Users, Audit Log
      - Org Admin: Dashboard, Employees, Departments, Settings, Audit Log
      - HR: Dashboard, Employees
      - Manager: Dashboard, My Team
      - Employee: Dashboard, My Profile
  </action>
  <verify>
    - `yarn tsc --noEmit` passes
    - Navigate to localhost:3000 — redirects to login or shows public page
    - Auth0 login flow works: redirects to Auth0 Universal Login, completes callback, lands on authenticated page
    - Session persists on page refresh (AUTH-04)
    - TenantService.withTenant() sets session variables correctly (test with raw SQL query checking current_setting)
  </verify>
  <done>
    Admin can log in via Auth0, session persists, user is synced to local DB with roles loaded. Authenticated layout renders with role-filtered navigation. TenantService sets RLS context for every query. Unauthenticated users redirected to login.
  </done>
</task>

<task type="auto">
  <name>Task 2: RBAC enforcement, role permission checks, and employee invitation flow</name>
  <files>
    app/api/auth/invite/route.ts
    app/api/auth/set-password/route.ts
    app/invite/[token]/page.tsx
    app/invite/[token]/set-password/page.tsx
    hooks/use-auth.ts
    hooks/use-tenant.ts
    providers/services/invitation.service.ts
    providers/repositories/employee.repository.ts
    schemas/auth.ts
  </files>
  <action>
    Create `hooks/use-auth.ts`:
    - Custom hook wrapping Auth0's useUser() hook
    - Returns: user (SessionUser), isLoading, isAuthenticated, roles, currentOrganisationId
    - Fetches extended user data (roles, permissions) from a `/api/auth/me` endpoint on mount
    - Memoize hasPermission check: `can(permission: string): boolean`

    Create `hooks/use-tenant.ts`:
    - Returns currentOrganisationId and setOrganisation (for platform admins switching between orgs)
    - Stores in Zustand store (app/stores/tenant-store.ts)

    Create `providers/repositories/employee.repository.ts` (partial — full CRUD in Plan 03):
    - Static class EmployeeRepository:
      - `findByInvitationToken(token: string): Promise<Employee | null>`
      - `updateInvitationStatus(employeeId: string, status: string): Promise<void>`
      - `clearInvitationToken(employeeId: string): Promise<void>`

    Create `providers/services/invitation.service.ts`:
    - Static class InvitationService:
      - `createInvitation(employeeId: string, organisationId: string): Promise<{ token: string; expiresAt: Date }>` — generate crypto.randomUUID() token, set invitation_expires_at to 7 days from now (per user decision), update employee record
      - `validateToken(token: string): Promise<{ valid: boolean; employee?: Employee; expired?: boolean }>` — find by token, check expiry, check not already used (status !== ACCEPTED)
      - `acceptInvitation(token: string, auth0Id: string, userId: string): Promise<void>` — mark accepted, clear token, link employee to user, assign EMPLOYEE role via UserService
      - `resendInvitation(employeeId: string): Promise<{ token: string; expiresAt: Date }>` — generate new token, reset expiry (per user decision: admin can resend)

    Create `app/api/auth/invite/route.ts`:
    - POST handler: accepts { employeeIds: string[] } (supports bulk invitations per user decision)
    - Validates caller has SEND_INVITATIONS permission
    - For each employee: creates invitation, generates magic link URL `/invite/[token]`
    - Returns list of generated invitation URLs (email sending deferred — just generate links for now)
    - Audit logs the invitation action

    Create `app/api/auth/set-password/route.ts`:
    - POST handler: accepts { token: string, password: string }
    - Validates invitation token via InvitationService
    - Creates Auth0 user with email/password via Auth0 Management API (`@auth0/nextjs-auth0` management client or direct API call)
    - Links Auth0 user to local user record
    - Marks invitation as accepted
    - Returns success with redirect URL to login
    - Per user decision: click magic link -> set password page -> straight to dashboard (no profile review step)

    Create `schemas/auth.ts`:
    - Zod schemas: SetPasswordSchema (password min 8 chars, requires number + letter), InviteSchema (employeeIds array of UUIDs)

    Create `app/invite/[token]/page.tsx`:
    - Server Component: validates token server-side via InvitationService
    - If valid: redirect to /invite/[token]/set-password
    - If expired: show "invitation expired, contact your administrator" message
    - If already used: redirect to login

    Create `app/invite/[token]/set-password/page.tsx`:
    - Client Component ('use client') with React Hook Form
    - Form: password + confirm password fields
    - Validates with SetPasswordSchema
    - On submit: POST to /api/auth/set-password
    - On success: redirect to Auth0 login (user logs in with new credentials)
    - Show loading state during submission
    - Clean, branded UI — this is the employee's first impression (per user decision: dashboard shell should feel like a real product)

    Create API route `app/api/auth/me/route.ts`:
    - GET handler: returns current user's SessionUser object (user + roles + permissions)
    - Used by useAuth hook to hydrate client-side auth state
  </action>
  <verify>
    - `yarn tsc --noEmit` passes
    - POST /api/auth/invite with valid employee IDs returns invitation URLs
    - Visiting /invite/[valid-token] redirects to set-password page
    - Visiting /invite/[expired-token] shows expiry message
    - POST /api/auth/set-password with valid token + password creates Auth0 user
    - useAuth hook returns user with roles and permissions
    - hasPermission correctly blocks/allows based on role
  </verify>
  <done>
    Employee invitation flow works end-to-end: admin creates invitation, employee clicks magic link, sets password, can then log in. RBAC enforced on API routes. Client-side useAuth hook provides role-aware auth state. Audit trail captures all auth-related actions.
  </done>
</task>

</tasks>

<verification>
1. Admin login via Auth0 works end-to-end (email/password -> callback -> authenticated page)
2. Session persists across refresh (AUTH-04)
3. RBAC enforces permissions — unauthorized access returns 403
4. Tenant context (RLS) is set per-request for org-scoped queries
5. Invitation flow: generate token -> validate -> set password -> login works
6. Magic links expire after 7 days and are single-use (AUTH-02, AUTH-03)
7. All auth actions are audit logged (COMP-01)
</verification>

<success_criteria>
- AUTH-01: Admin users log in with email/password via Auth0
- AUTH-02/03: Magic link invitation flow with 7-day expiry, single-use tokens
- AUTH-04: Sessions persist across refresh
- AUTH-05: 5-tier RBAC with permission checks
- AUTH-07: Tenant isolation via RLS session variables
- Authenticated layout renders with role-filtered navigation
- Client-side auth hooks provide roles and permission checks
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-access/01-02-SUMMARY.md`
</output>
